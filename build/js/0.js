webpackJsonp([0],{

/***/ 26:
/***/ (function(module, exports) {

eval("/**\n * @name InfoBox\n * @version 1.1.13 [March 19, 2014]\n * @author Gary Little (inspired by proof-of-concept code from Pamela Fox of Google)\n * @copyright Copyright 2010 Gary Little [gary at luxcentral.com]\n * @fileoverview InfoBox extends the Google Maps JavaScript API V3 <tt>OverlayView</tt> class.\n *  <p>\n *  An InfoBox behaves like a <tt>google.maps.InfoWindow</tt>, but it supports several\n *  additional properties for advanced styling. An InfoBox can also be used as a map label.\n *  <p>\n *  An InfoBox also fires the same events as a <tt>google.maps.InfoWindow</tt>.\n */\n\n/*!\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*jslint browser:true */\n/*global google */\n\n/**\n * @name InfoBoxOptions\n * @class This class represents the optional parameter passed to the {@link InfoBox} constructor.\n * @property {string|Node} content The content of the InfoBox (plain text or an HTML DOM node).\n * @property {boolean} [disableAutoPan=false] Disable auto-pan on <tt>open</tt>.\n * @property {number} maxWidth The maximum width (in pixels) of the InfoBox. Set to 0 if no maximum.\n * @property {Size} pixelOffset The offset (in pixels) from the top left corner of the InfoBox\n *  (or the bottom left corner if the <code>alignBottom</code> property is <code>true</code>)\n *  to the map pixel corresponding to <tt>position</tt>.\n * @property {LatLng} position The geographic location at which to display the InfoBox.\n * @property {number} zIndex The CSS z-index style value for the InfoBox.\n *  Note: This value overrides a zIndex setting specified in the <tt>boxStyle</tt> property.\n * @property {string} [boxClass=\"infoBox\"] The name of the CSS class defining the styles for the InfoBox container.\n * @property {Object} [boxStyle] An object literal whose properties define specific CSS\n *  style values to be applied to the InfoBox. Style values defined here override those that may\n *  be defined in the <code>boxClass</code> style sheet. If this property is changed after the\n *  InfoBox has been created, all previously set styles (except those defined in the style sheet)\n *  are removed from the InfoBox before the new style values are applied.\n * @property {string} closeBoxMargin The CSS margin style value for the close box.\n *  The default is \"2px\" (a 2-pixel margin on all sides).\n * @property {string} closeBoxURL The URL of the image representing the close box.\n *  Note: The default is the URL for Google's standard close box.\n *  Set this property to \"\" if no close box is required.\n * @property {Size} infoBoxClearance Minimum offset (in pixels) from the InfoBox to the\n *  map edge after an auto-pan.\n * @property {boolean} [isHidden=false] Hide the InfoBox on <tt>open</tt>.\n *  [Deprecated in favor of the <tt>visible</tt> property.]\n * @property {boolean} [visible=true] Show the InfoBox on <tt>open</tt>.\n * @property {boolean} alignBottom Align the bottom left corner of the InfoBox to the <code>position</code>\n *  location (default is <tt>false</tt> which means that the top left corner of the InfoBox is aligned).\n * @property {string} pane The pane where the InfoBox is to appear (default is \"floatPane\").\n *  Set the pane to \"mapPane\" if the InfoBox is being used as a map label.\n *  Valid pane names are the property names for the <tt>google.maps.MapPanes</tt> object.\n * @property {boolean} enableEventPropagation Propagate mousedown, mousemove, mouseover, mouseout,\n *  mouseup, click, dblclick, touchstart, touchend, touchmove, and contextmenu events in the InfoBox\n *  (default is <tt>false</tt> to mimic the behavior of a <tt>google.maps.InfoWindow</tt>). Set\n *  this property to <tt>true</tt> if the InfoBox is being used as a map label.\n */\n\n/**\n * Creates an InfoBox with the options specified in {@link InfoBoxOptions}.\n *  Call <tt>InfoBox.open</tt> to add the box to the map.\n * @constructor\n * @param {InfoBoxOptions} [opt_opts]\n */\nfunction InfoBox(opt_opts) {\n\n  opt_opts = opt_opts || {};\n\n  google.maps.OverlayView.apply(this, arguments);\n\n  // Standard options (in common with google.maps.InfoWindow):\n  //\n  this.content_ = opt_opts.content || \"\";\n  this.disableAutoPan_ = opt_opts.disableAutoPan || false;\n  this.maxWidth_ = opt_opts.maxWidth || 0;\n  this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);\n  this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);\n  this.zIndex_ = opt_opts.zIndex || null;\n\n  // Additional options (unique to InfoBox):\n  //\n  this.boxClass_ = opt_opts.boxClass || \"infoBox\";\n  this.boxStyle_ = opt_opts.boxStyle || {};\n  this.closeBoxMargin_ = opt_opts.closeBoxMargin || \"2px\";\n  this.closeBoxURL_ = opt_opts.closeBoxURL || \"http://www.google.com/intl/en_us/mapfiles/close.gif\";\n  if (opt_opts.closeBoxURL === \"\") {\n    this.closeBoxURL_ = \"\";\n  }\n  this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);\n\n  if (typeof opt_opts.visible === \"undefined\") {\n    if (typeof opt_opts.isHidden === \"undefined\") {\n      opt_opts.visible = true;\n    } else {\n      opt_opts.visible = !opt_opts.isHidden;\n    }\n  }\n  this.isHidden_ = !opt_opts.visible;\n\n  this.alignBottom_ = opt_opts.alignBottom || false;\n  this.pane_ = opt_opts.pane || \"floatPane\";\n  this.enableEventPropagation_ = opt_opts.enableEventPropagation || false;\n\n  this.div_ = null;\n  this.closeListener_ = null;\n  this.moveListener_ = null;\n  this.mapListener_ = null;\n  this.contextListener_ = null;\n  this.eventListeners_ = null;\n  this.fixedWidthSet_ = null;\n}\n\n/* InfoBox extends OverlayView in the Google Maps API v3.\n */\nInfoBox.prototype = new google.maps.OverlayView();\n\n/**\n * Creates the DIV representing the InfoBox.\n * @private\n */\nInfoBox.prototype.createInfoBoxDiv_ = function () {\n\n  var i;\n  var events;\n  var bw;\n  var me = this;\n\n  // This handler prevents an event in the InfoBox from being passed on to the map.\n  //\n  var cancelHandler = function (e) {\n    e.cancelBubble = true;\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    }\n  };\n\n  // This handler ignores the current event in the InfoBox and conditionally prevents\n  // the event from being passed on to the map. It is used for the contextmenu event.\n  //\n  var ignoreHandler = function (e) {\n\n    e.returnValue = false;\n\n    if (e.preventDefault) {\n\n      e.preventDefault();\n    }\n\n    if (!me.enableEventPropagation_) {\n\n      cancelHandler(e);\n    }\n  };\n\n  if (!this.div_) {\n\n    this.div_ = document.createElement(\"div\");\n\n    this.setBoxStyle_();\n\n    if (typeof this.content_.nodeType === \"undefined\") {\n      this.div_.innerHTML = this.getCloseBoxImg_() + this.content_;\n    } else {\n      this.div_.innerHTML = this.getCloseBoxImg_();\n      this.div_.appendChild(this.content_);\n    }\n\n    // Add the InfoBox DIV to the DOM\n    this.getPanes()[this.pane_].appendChild(this.div_);\n\n    this.addClickHandler_();\n\n    if (this.div_.style.width) {\n\n      this.fixedWidthSet_ = true;\n\n    } else {\n\n      if (this.maxWidth_ !== 0 && this.div_.offsetWidth > this.maxWidth_) {\n\n        this.div_.style.width = this.maxWidth_;\n        this.fixedWidthSet_ = true;\n\n      } else { // The following code is needed to overcome problems with MSIE\n\n        bw = this.getBoxWidths_();\n\n        this.div_.style.width = (this.div_.offsetWidth - bw.left - bw.right) + \"px\";\n        this.fixedWidthSet_ = false;\n      }\n    }\n\n    this.panBox_(this.disableAutoPan_);\n\n    if (!this.enableEventPropagation_) {\n\n      this.eventListeners_ = [];\n\n      // Cancel event propagation.\n      //\n      // Note: mousemove not included (to resolve Issue 152)\n      events = [\"mousedown\", \"mouseover\", \"mouseout\", \"mouseup\",\n      \"click\", \"dblclick\", \"touchstart\", \"touchend\", \"touchmove\"];\n\n      for (i = 0; i < events.length; i++) {\n\n        this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));\n      }\n      \n      // Workaround for Google bug that causes the cursor to change to a pointer\n      // when the mouse moves over a marker underneath InfoBox.\n      this.eventListeners_.push(google.maps.event.addDomListener(this.div_, \"mouseover\", function (e) {\n        this.style.cursor = \"default\";\n      }));\n    }\n\n    this.contextListener_ = google.maps.event.addDomListener(this.div_, \"contextmenu\", ignoreHandler);\n\n    /**\n     * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.\n     * @name InfoBox#domready\n     * @event\n     */\n    google.maps.event.trigger(this, \"domready\");\n  }\n};\n\n/**\n * Returns the HTML <IMG> tag for the close box.\n * @private\n */\nInfoBox.prototype.getCloseBoxImg_ = function () {\n\n  var img = \"\";\n\n  if (this.closeBoxURL_ !== \"\") {\n\n    img  = \"<img\";\n    img += \" src='\" + this.closeBoxURL_ + \"'\";\n    img += \" align=right\"; // Do this because Opera chokes on style='float: right;'\n    img += \" style='\";\n    img += \" position: relative;\"; // Required by MSIE\n    img += \" cursor: pointer;\";\n    img += \" margin: \" + this.closeBoxMargin_ + \";\";\n    img += \"'>\";\n  }\n\n  return img;\n};\n\n/**\n * Adds the click handler to the InfoBox close box.\n * @private\n */\nInfoBox.prototype.addClickHandler_ = function () {\n\n  var closeBox;\n\n  if (this.closeBoxURL_ !== \"\") {\n\n    closeBox = this.div_.firstChild;\n    this.closeListener_ = google.maps.event.addDomListener(closeBox, \"click\", this.getCloseClickHandler_());\n\n  } else {\n\n    this.closeListener_ = null;\n  }\n};\n\n/**\n * Returns the function to call when the user clicks the close box of an InfoBox.\n * @private\n */\nInfoBox.prototype.getCloseClickHandler_ = function () {\n\n  var me = this;\n\n  return function (e) {\n\n    // 1.0.3 fix: Always prevent propagation of a close box click to the map:\n    e.cancelBubble = true;\n\n    if (e.stopPropagation) {\n\n      e.stopPropagation();\n    }\n\n    /**\n     * This event is fired when the InfoBox's close box is clicked.\n     * @name InfoBox#closeclick\n     * @event\n     */\n    google.maps.event.trigger(me, \"closeclick\");\n\n    me.close();\n  };\n};\n\n/**\n * Pans the map so that the InfoBox appears entirely within the map's visible area.\n * @private\n */\nInfoBox.prototype.panBox_ = function (disablePan) {\n\n  var map;\n  var bounds;\n  var xOffset = 0, yOffset = 0;\n\n  if (!disablePan) {\n\n    map = this.getMap();\n\n    if (map instanceof google.maps.Map) { // Only pan if attached to map, not panorama\n\n      if (!map.getBounds().contains(this.position_)) {\n      // Marker not in visible area of map, so set center\n      // of map to the marker position first.\n        map.setCenter(this.position_);\n      }\n\n      bounds = map.getBounds();\n\n      var mapDiv = map.getDiv();\n      var mapWidth = mapDiv.offsetWidth;\n      var mapHeight = mapDiv.offsetHeight;\n      var iwOffsetX = this.pixelOffset_.width;\n      var iwOffsetY = this.pixelOffset_.height;\n      var iwWidth = this.div_.offsetWidth;\n      var iwHeight = this.div_.offsetHeight;\n      var padX = this.infoBoxClearance_.width;\n      var padY = this.infoBoxClearance_.height;\n      var pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);\n\n      if (pixPosition.x < (-iwOffsetX + padX)) {\n        xOffset = pixPosition.x + iwOffsetX - padX;\n      } else if ((pixPosition.x + iwWidth + iwOffsetX + padX) > mapWidth) {\n        xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;\n      }\n      if (this.alignBottom_) {\n        if (pixPosition.y < (-iwOffsetY + padY + iwHeight)) {\n          yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;\n        } else if ((pixPosition.y + iwOffsetY + padY) > mapHeight) {\n          yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;\n        }\n      } else {\n        if (pixPosition.y < (-iwOffsetY + padY)) {\n          yOffset = pixPosition.y + iwOffsetY - padY;\n        } else if ((pixPosition.y + iwHeight + iwOffsetY + padY) > mapHeight) {\n          yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;\n        }\n      }\n\n      if (!(xOffset === 0 && yOffset === 0)) {\n\n        // Move the map to the shifted center.\n        //\n        var c = map.getCenter();\n        map.panBy(xOffset, yOffset);\n      }\n    }\n  }\n};\n\n/**\n * Sets the style of the InfoBox by setting the style sheet and applying\n * other specific styles requested.\n * @private\n */\nInfoBox.prototype.setBoxStyle_ = function () {\n\n  var i, boxStyle;\n\n  if (this.div_) {\n\n    // Apply style values from the style sheet defined in the boxClass parameter:\n    this.div_.className = this.boxClass_;\n\n    // Clear existing inline style values:\n    this.div_.style.cssText = \"\";\n\n    // Apply style values defined in the boxStyle parameter:\n    boxStyle = this.boxStyle_;\n    for (i in boxStyle) {\n\n      if (boxStyle.hasOwnProperty(i)) {\n\n        this.div_.style[i] = boxStyle[i];\n      }\n    }\n\n    // Fix for iOS disappearing InfoBox problem.\n    // See http://stackoverflow.com/questions/9229535/google-maps-markers-disappear-at-certain-zoom-level-only-on-iphone-ipad\n    this.div_.style.WebkitTransform = \"translateZ(0)\";\n\n    // Fix up opacity style for benefit of MSIE:\n    //\n    if (typeof this.div_.style.opacity !== \"undefined\" && this.div_.style.opacity !== \"\") {\n      // See http://www.quirksmode.org/css/opacity.html\n      this.div_.style.MsFilter = \"\\\"progid:DXImageTransform.Microsoft.Alpha(Opacity=\" + (this.div_.style.opacity * 100) + \")\\\"\";\n      this.div_.style.filter = \"alpha(opacity=\" + (this.div_.style.opacity * 100) + \")\";\n    }\n\n    // Apply required styles:\n    //\n    this.div_.style.position = \"absolute\";\n    this.div_.style.visibility = 'hidden';\n    if (this.zIndex_ !== null) {\n\n      this.div_.style.zIndex = this.zIndex_;\n    }\n    if (!this.div_.style.overflow) {\n      this.div_.style.overflow = \"auto\";\n    }\n  }\n};\n\n/**\n * Get the widths of the borders of the InfoBox.\n * @private\n * @return {Object} widths object (top, bottom left, right)\n */\nInfoBox.prototype.getBoxWidths_ = function () {\n\n  var computedStyle;\n  var bw = {top: 0, bottom: 0, left: 0, right: 0};\n  var box = this.div_;\n\n  if (document.defaultView && document.defaultView.getComputedStyle) {\n\n    computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, \"\");\n\n    if (computedStyle) {\n\n      // The computed styles are always in pixel units (good!)\n      bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;\n      bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n      bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n      bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;\n    }\n\n  } else if (document.documentElement.currentStyle) { // MSIE\n\n    if (box.currentStyle) {\n\n      // The current styles may not be in pixel units, but assume they are (bad!)\n      bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;\n      bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;\n      bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;\n      bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;\n    }\n  }\n\n  return bw;\n};\n\n/**\n * Invoked when <tt>close</tt> is called. Do not call it directly.\n */\nInfoBox.prototype.onRemove = function () {\n\n  if (this.div_) {\n\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n/**\n * Draws the InfoBox based on the current map projection and zoom level.\n */\nInfoBox.prototype.draw = function () {\n\n  this.createInfoBoxDiv_();\n\n  var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);\n\n  this.div_.style.left = (pixPosition.x + this.pixelOffset_.width) + \"px\";\n  \n  if (this.alignBottom_) {\n    this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + \"px\";\n  } else {\n    this.div_.style.top = (pixPosition.y + this.pixelOffset_.height) + \"px\";\n  }\n\n  if (this.isHidden_) {\n\n    this.div_.style.visibility = \"hidden\";\n\n  } else {\n\n    this.div_.style.visibility = \"visible\";\n  }\n};\n\n/**\n * Sets the options for the InfoBox. Note that changes to the <tt>maxWidth</tt>,\n *  <tt>closeBoxMargin</tt>, <tt>closeBoxURL</tt>, and <tt>enableEventPropagation</tt>\n *  properties have no affect until the current InfoBox is <tt>close</tt>d and a new one\n *  is <tt>open</tt>ed.\n * @param {InfoBoxOptions} opt_opts\n */\nInfoBox.prototype.setOptions = function (opt_opts) {\n  if (typeof opt_opts.boxClass !== \"undefined\") { // Must be first\n\n    this.boxClass_ = opt_opts.boxClass;\n    this.setBoxStyle_();\n  }\n  if (typeof opt_opts.boxStyle !== \"undefined\") { // Must be second\n\n    this.boxStyle_ = opt_opts.boxStyle;\n    this.setBoxStyle_();\n  }\n  if (typeof opt_opts.content !== \"undefined\") {\n\n    this.setContent(opt_opts.content);\n  }\n  if (typeof opt_opts.disableAutoPan !== \"undefined\") {\n\n    this.disableAutoPan_ = opt_opts.disableAutoPan;\n  }\n  if (typeof opt_opts.maxWidth !== \"undefined\") {\n\n    this.maxWidth_ = opt_opts.maxWidth;\n  }\n  if (typeof opt_opts.pixelOffset !== \"undefined\") {\n\n    this.pixelOffset_ = opt_opts.pixelOffset;\n  }\n  if (typeof opt_opts.alignBottom !== \"undefined\") {\n\n    this.alignBottom_ = opt_opts.alignBottom;\n  }\n  if (typeof opt_opts.position !== \"undefined\") {\n\n    this.setPosition(opt_opts.position);\n  }\n  if (typeof opt_opts.zIndex !== \"undefined\") {\n\n    this.setZIndex(opt_opts.zIndex);\n  }\n  if (typeof opt_opts.closeBoxMargin !== \"undefined\") {\n\n    this.closeBoxMargin_ = opt_opts.closeBoxMargin;\n  }\n  if (typeof opt_opts.closeBoxURL !== \"undefined\") {\n\n    this.closeBoxURL_ = opt_opts.closeBoxURL;\n  }\n  if (typeof opt_opts.infoBoxClearance !== \"undefined\") {\n\n    this.infoBoxClearance_ = opt_opts.infoBoxClearance;\n  }\n  if (typeof opt_opts.isHidden !== \"undefined\") {\n\n    this.isHidden_ = opt_opts.isHidden;\n  }\n  if (typeof opt_opts.visible !== \"undefined\") {\n\n    this.isHidden_ = !opt_opts.visible;\n  }\n  if (typeof opt_opts.enableEventPropagation !== \"undefined\") {\n\n    this.enableEventPropagation_ = opt_opts.enableEventPropagation;\n  }\n\n  if (this.div_) {\n\n    this.draw();\n  }\n};\n\n/**\n * Sets the content of the InfoBox.\n *  The content can be plain text or an HTML DOM node.\n * @param {string|Node} content\n */\nInfoBox.prototype.setContent = function (content) {\n  this.content_ = content;\n\n  if (this.div_) {\n\n    if (this.closeListener_) {\n\n      google.maps.event.removeListener(this.closeListener_);\n      this.closeListener_ = null;\n    }\n\n    // Odd code required to make things work with MSIE.\n    //\n    if (!this.fixedWidthSet_) {\n\n      this.div_.style.width = \"\";\n    }\n\n    if (typeof content.nodeType === \"undefined\") {\n      this.div_.innerHTML = this.getCloseBoxImg_() + content;\n    } else {\n      this.div_.innerHTML = this.getCloseBoxImg_();\n      this.div_.appendChild(content);\n    }\n\n    // Perverse code required to make things work with MSIE.\n    // (Ensures the close box does, in fact, float to the right.)\n    //\n    if (!this.fixedWidthSet_) {\n      this.div_.style.width = this.div_.offsetWidth + \"px\";\n      if (typeof content.nodeType === \"undefined\") {\n        this.div_.innerHTML = this.getCloseBoxImg_() + content;\n      } else {\n        this.div_.innerHTML = this.getCloseBoxImg_();\n        this.div_.appendChild(content);\n      }\n    }\n\n    this.addClickHandler_();\n  }\n\n  /**\n   * This event is fired when the content of the InfoBox changes.\n   * @name InfoBox#content_changed\n   * @event\n   */\n  google.maps.event.trigger(this, \"content_changed\");\n};\n\n/**\n * Sets the geographic location of the InfoBox.\n * @param {LatLng} latlng\n */\nInfoBox.prototype.setPosition = function (latlng) {\n\n  this.position_ = latlng;\n\n  if (this.div_) {\n\n    this.draw();\n  }\n\n  /**\n   * This event is fired when the position of the InfoBox changes.\n   * @name InfoBox#position_changed\n   * @event\n   */\n  google.maps.event.trigger(this, \"position_changed\");\n};\n\n/**\n * Sets the zIndex style for the InfoBox.\n * @param {number} index\n */\nInfoBox.prototype.setZIndex = function (index) {\n\n  this.zIndex_ = index;\n\n  if (this.div_) {\n\n    this.div_.style.zIndex = index;\n  }\n\n  /**\n   * This event is fired when the zIndex of the InfoBox changes.\n   * @name InfoBox#zindex_changed\n   * @event\n   */\n  google.maps.event.trigger(this, \"zindex_changed\");\n};\n\n/**\n * Sets the visibility of the InfoBox.\n * @param {boolean} isVisible\n */\nInfoBox.prototype.setVisible = function (isVisible) {\n\n  this.isHidden_ = !isVisible;\n  if (this.div_) {\n    this.div_.style.visibility = (this.isHidden_ ? \"hidden\" : \"visible\");\n  }\n};\n\n/**\n * Returns the content of the InfoBox.\n * @returns {string}\n */\nInfoBox.prototype.getContent = function () {\n\n  return this.content_;\n};\n\n/**\n * Returns the geographic location of the InfoBox.\n * @returns {LatLng}\n */\nInfoBox.prototype.getPosition = function () {\n\n  return this.position_;\n};\n\n/**\n * Returns the zIndex for the InfoBox.\n * @returns {number}\n */\nInfoBox.prototype.getZIndex = function () {\n\n  return this.zIndex_;\n};\n\n/**\n * Returns a flag indicating whether the InfoBox is visible.\n * @returns {boolean}\n */\nInfoBox.prototype.getVisible = function () {\n\n  var isVisible;\n\n  if ((typeof this.getMap() === \"undefined\") || (this.getMap() === null)) {\n    isVisible = false;\n  } else {\n    isVisible = !this.isHidden_;\n  }\n  return isVisible;\n};\n\n/**\n * Shows the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]\n */\nInfoBox.prototype.show = function () {\n\n  this.isHidden_ = false;\n  if (this.div_) {\n    this.div_.style.visibility = \"visible\";\n  }\n};\n\n/**\n * Hides the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]\n */\nInfoBox.prototype.hide = function () {\n\n  this.isHidden_ = true;\n  if (this.div_) {\n    this.div_.style.visibility = \"hidden\";\n  }\n};\n\n/**\n * Adds the InfoBox to the specified map or Street View panorama. If <tt>anchor</tt>\n *  (usually a <tt>google.maps.Marker</tt>) is specified, the position\n *  of the InfoBox is set to the position of the <tt>anchor</tt>. If the\n *  anchor is dragged to a new location, the InfoBox moves as well.\n * @param {Map|StreetViewPanorama} map\n * @param {MVCObject} [anchor]\n */\nInfoBox.prototype.open = function (map, anchor) {\n\n  var me = this;\n\n  if (anchor) {\n\n    this.position_ = anchor.getPosition();\n    this.moveListener_ = google.maps.event.addListener(anchor, \"position_changed\", function () {\n      me.setPosition(this.getPosition());\n    });\n\n    this.mapListener_ = google.maps.event.addListener(anchor, \"map_changed\", function() {\n      me.setMap(this.map);\n    });    \n  }\n\n  this.setMap(map);\n\n  if (this.div_) {\n\n    this.panBox_();\n  }\n};\n\n/**\n * Removes the InfoBox from the map.\n */\nInfoBox.prototype.close = function () {\n\n  var i;\n\n  if (this.closeListener_) {\n\n    google.maps.event.removeListener(this.closeListener_);\n    this.closeListener_ = null;\n  }\n\n  if (this.eventListeners_) {\n    \n    for (i = 0; i < this.eventListeners_.length; i++) {\n\n      google.maps.event.removeListener(this.eventListeners_[i]);\n    }\n    this.eventListeners_ = null;\n  }\n\n  if (this.moveListener_) {\n\n    google.maps.event.removeListener(this.moveListener_);\n    this.moveListener_ = null;\n  }\n\n  if (this.mapListener_) {\n    \n    google.maps.event.removeListener(this.mapListener_);\n    this.mapListener_ = null;    \n  }\n \n  if (this.contextListener_) {\n\n    google.maps.event.removeListener(this.contextListener_);\n    this.contextListener_ = null;\n  }\n\n  this.setMap(null);\n};\n\n\nmodule.exports = InfoBox;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vRDovdml0YWxpay9sYXRjb20vfi9nb29nbGUtbWFwcy1pbmZvYm94L2luZm9ib3gtbW9kdWxlLmpzPzFmOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbmFtZSBJbmZvQm94XG4gKiBAdmVyc2lvbiAxLjEuMTMgW01hcmNoIDE5LCAyMDE0XVxuICogQGF1dGhvciBHYXJ5IExpdHRsZSAoaW5zcGlyZWQgYnkgcHJvb2Ytb2YtY29uY2VwdCBjb2RlIGZyb20gUGFtZWxhIEZveCBvZiBHb29nbGUpXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAyMDEwIEdhcnkgTGl0dGxlIFtnYXJ5IGF0IGx1eGNlbnRyYWwuY29tXVxuICogQGZpbGVvdmVydmlldyBJbmZvQm94IGV4dGVuZHMgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJIFYzIDx0dD5PdmVybGF5VmlldzwvdHQ+IGNsYXNzLlxuICogIDxwPlxuICogIEFuIEluZm9Cb3ggYmVoYXZlcyBsaWtlIGEgPHR0Pmdvb2dsZS5tYXBzLkluZm9XaW5kb3c8L3R0PiwgYnV0IGl0IHN1cHBvcnRzIHNldmVyYWxcbiAqICBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIGFkdmFuY2VkIHN0eWxpbmcuIEFuIEluZm9Cb3ggY2FuIGFsc28gYmUgdXNlZCBhcyBhIG1hcCBsYWJlbC5cbiAqICA8cD5cbiAqICBBbiBJbmZvQm94IGFsc28gZmlyZXMgdGhlIHNhbWUgZXZlbnRzIGFzIGEgPHR0Pmdvb2dsZS5tYXBzLkluZm9XaW5kb3c8L3R0Pi5cbiAqL1xuXG4vKiFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKmpzbGludCBicm93c2VyOnRydWUgKi9cbi8qZ2xvYmFsIGdvb2dsZSAqL1xuXG4vKipcbiAqIEBuYW1lIEluZm9Cb3hPcHRpb25zXG4gKiBAY2xhc3MgVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSB7QGxpbmsgSW5mb0JveH0gY29uc3RydWN0b3IuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xOb2RlfSBjb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBJbmZvQm94IChwbGFpbiB0ZXh0IG9yIGFuIEhUTUwgRE9NIG5vZGUpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGlzYWJsZUF1dG9QYW49ZmFsc2VdIERpc2FibGUgYXV0by1wYW4gb24gPHR0Pm9wZW48L3R0Pi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhXaWR0aCBUaGUgbWF4aW11bSB3aWR0aCAoaW4gcGl4ZWxzKSBvZiB0aGUgSW5mb0JveC4gU2V0IHRvIDAgaWYgbm8gbWF4aW11bS5cbiAqIEBwcm9wZXJ0eSB7U2l6ZX0gcGl4ZWxPZmZzZXQgVGhlIG9mZnNldCAoaW4gcGl4ZWxzKSBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIEluZm9Cb3hcbiAqICAob3IgdGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBpZiB0aGUgPGNvZGU+YWxpZ25Cb3R0b208L2NvZGU+IHByb3BlcnR5IGlzIDxjb2RlPnRydWU8L2NvZGU+KVxuICogIHRvIHRoZSBtYXAgcGl4ZWwgY29ycmVzcG9uZGluZyB0byA8dHQ+cG9zaXRpb248L3R0Pi5cbiAqIEBwcm9wZXJ0eSB7TGF0TG5nfSBwb3NpdGlvbiBUaGUgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBhdCB3aGljaCB0byBkaXNwbGF5IHRoZSBJbmZvQm94LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpJbmRleCBUaGUgQ1NTIHotaW5kZXggc3R5bGUgdmFsdWUgZm9yIHRoZSBJbmZvQm94LlxuICogIE5vdGU6IFRoaXMgdmFsdWUgb3ZlcnJpZGVzIGEgekluZGV4IHNldHRpbmcgc3BlY2lmaWVkIGluIHRoZSA8dHQ+Ym94U3R5bGU8L3R0PiBwcm9wZXJ0eS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYm94Q2xhc3M9XCJpbmZvQm94XCJdIFRoZSBuYW1lIG9mIHRoZSBDU1MgY2xhc3MgZGVmaW5pbmcgdGhlIHN0eWxlcyBmb3IgdGhlIEluZm9Cb3ggY29udGFpbmVyLlxuICogQHByb3BlcnR5IHtPYmplY3R9IFtib3hTdHlsZV0gQW4gb2JqZWN0IGxpdGVyYWwgd2hvc2UgcHJvcGVydGllcyBkZWZpbmUgc3BlY2lmaWMgQ1NTXG4gKiAgc3R5bGUgdmFsdWVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIEluZm9Cb3guIFN0eWxlIHZhbHVlcyBkZWZpbmVkIGhlcmUgb3ZlcnJpZGUgdGhvc2UgdGhhdCBtYXlcbiAqICBiZSBkZWZpbmVkIGluIHRoZSA8Y29kZT5ib3hDbGFzczwvY29kZT4gc3R5bGUgc2hlZXQuIElmIHRoaXMgcHJvcGVydHkgaXMgY2hhbmdlZCBhZnRlciB0aGVcbiAqICBJbmZvQm94IGhhcyBiZWVuIGNyZWF0ZWQsIGFsbCBwcmV2aW91c2x5IHNldCBzdHlsZXMgKGV4Y2VwdCB0aG9zZSBkZWZpbmVkIGluIHRoZSBzdHlsZSBzaGVldClcbiAqICBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBJbmZvQm94IGJlZm9yZSB0aGUgbmV3IHN0eWxlIHZhbHVlcyBhcmUgYXBwbGllZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjbG9zZUJveE1hcmdpbiBUaGUgQ1NTIG1hcmdpbiBzdHlsZSB2YWx1ZSBmb3IgdGhlIGNsb3NlIGJveC5cbiAqICBUaGUgZGVmYXVsdCBpcyBcIjJweFwiIChhIDItcGl4ZWwgbWFyZ2luIG9uIGFsbCBzaWRlcykuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2xvc2VCb3hVUkwgVGhlIFVSTCBvZiB0aGUgaW1hZ2UgcmVwcmVzZW50aW5nIHRoZSBjbG9zZSBib3guXG4gKiAgTm90ZTogVGhlIGRlZmF1bHQgaXMgdGhlIFVSTCBmb3IgR29vZ2xlJ3Mgc3RhbmRhcmQgY2xvc2UgYm94LlxuICogIFNldCB0aGlzIHByb3BlcnR5IHRvIFwiXCIgaWYgbm8gY2xvc2UgYm94IGlzIHJlcXVpcmVkLlxuICogQHByb3BlcnR5IHtTaXplfSBpbmZvQm94Q2xlYXJhbmNlIE1pbmltdW0gb2Zmc2V0IChpbiBwaXhlbHMpIGZyb20gdGhlIEluZm9Cb3ggdG8gdGhlXG4gKiAgbWFwIGVkZ2UgYWZ0ZXIgYW4gYXV0by1wYW4uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpc0hpZGRlbj1mYWxzZV0gSGlkZSB0aGUgSW5mb0JveCBvbiA8dHQ+b3BlbjwvdHQ+LlxuICogIFtEZXByZWNhdGVkIGluIGZhdm9yIG9mIHRoZSA8dHQ+dmlzaWJsZTwvdHQ+IHByb3BlcnR5Ll1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gU2hvdyB0aGUgSW5mb0JveCBvbiA8dHQ+b3BlbjwvdHQ+LlxuICogQHByb3BlcnR5IHtib29sZWFufSBhbGlnbkJvdHRvbSBBbGlnbiB0aGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBJbmZvQm94IHRvIHRoZSA8Y29kZT5wb3NpdGlvbjwvY29kZT5cbiAqICBsb2NhdGlvbiAoZGVmYXVsdCBpcyA8dHQ+ZmFsc2U8L3R0PiB3aGljaCBtZWFucyB0aGF0IHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIEluZm9Cb3ggaXMgYWxpZ25lZCkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGFuZSBUaGUgcGFuZSB3aGVyZSB0aGUgSW5mb0JveCBpcyB0byBhcHBlYXIgKGRlZmF1bHQgaXMgXCJmbG9hdFBhbmVcIikuXG4gKiAgU2V0IHRoZSBwYW5lIHRvIFwibWFwUGFuZVwiIGlmIHRoZSBJbmZvQm94IGlzIGJlaW5nIHVzZWQgYXMgYSBtYXAgbGFiZWwuXG4gKiAgVmFsaWQgcGFuZSBuYW1lcyBhcmUgdGhlIHByb3BlcnR5IG5hbWVzIGZvciB0aGUgPHR0Pmdvb2dsZS5tYXBzLk1hcFBhbmVzPC90dD4gb2JqZWN0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBlbmFibGVFdmVudFByb3BhZ2F0aW9uIFByb3BhZ2F0ZSBtb3VzZWRvd24sIG1vdXNlbW92ZSwgbW91c2VvdmVyLCBtb3VzZW91dCxcbiAqICBtb3VzZXVwLCBjbGljaywgZGJsY2xpY2ssIHRvdWNoc3RhcnQsIHRvdWNoZW5kLCB0b3VjaG1vdmUsIGFuZCBjb250ZXh0bWVudSBldmVudHMgaW4gdGhlIEluZm9Cb3hcbiAqICAoZGVmYXVsdCBpcyA8dHQ+ZmFsc2U8L3R0PiB0byBtaW1pYyB0aGUgYmVoYXZpb3Igb2YgYSA8dHQ+Z29vZ2xlLm1hcHMuSW5mb1dpbmRvdzwvdHQ+KS4gU2V0XG4gKiAgdGhpcyBwcm9wZXJ0eSB0byA8dHQ+dHJ1ZTwvdHQ+IGlmIHRoZSBJbmZvQm94IGlzIGJlaW5nIHVzZWQgYXMgYSBtYXAgbGFiZWwuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEluZm9Cb3ggd2l0aCB0aGUgb3B0aW9ucyBzcGVjaWZpZWQgaW4ge0BsaW5rIEluZm9Cb3hPcHRpb25zfS5cbiAqICBDYWxsIDx0dD5JbmZvQm94Lm9wZW48L3R0PiB0byBhZGQgdGhlIGJveCB0byB0aGUgbWFwLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0luZm9Cb3hPcHRpb25zfSBbb3B0X29wdHNdXG4gKi9cbmZ1bmN0aW9uIEluZm9Cb3gob3B0X29wdHMpIHtcblxuICBvcHRfb3B0cyA9IG9wdF9vcHRzIHx8IHt9O1xuXG4gIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gU3RhbmRhcmQgb3B0aW9ucyAoaW4gY29tbW9uIHdpdGggZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyk6XG4gIC8vXG4gIHRoaXMuY29udGVudF8gPSBvcHRfb3B0cy5jb250ZW50IHx8IFwiXCI7XG4gIHRoaXMuZGlzYWJsZUF1dG9QYW5fID0gb3B0X29wdHMuZGlzYWJsZUF1dG9QYW4gfHwgZmFsc2U7XG4gIHRoaXMubWF4V2lkdGhfID0gb3B0X29wdHMubWF4V2lkdGggfHwgMDtcbiAgdGhpcy5waXhlbE9mZnNldF8gPSBvcHRfb3B0cy5waXhlbE9mZnNldCB8fCBuZXcgZ29vZ2xlLm1hcHMuU2l6ZSgwLCAwKTtcbiAgdGhpcy5wb3NpdGlvbl8gPSBvcHRfb3B0cy5wb3NpdGlvbiB8fCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKDAsIDApO1xuICB0aGlzLnpJbmRleF8gPSBvcHRfb3B0cy56SW5kZXggfHwgbnVsbDtcblxuICAvLyBBZGRpdGlvbmFsIG9wdGlvbnMgKHVuaXF1ZSB0byBJbmZvQm94KTpcbiAgLy9cbiAgdGhpcy5ib3hDbGFzc18gPSBvcHRfb3B0cy5ib3hDbGFzcyB8fCBcImluZm9Cb3hcIjtcbiAgdGhpcy5ib3hTdHlsZV8gPSBvcHRfb3B0cy5ib3hTdHlsZSB8fCB7fTtcbiAgdGhpcy5jbG9zZUJveE1hcmdpbl8gPSBvcHRfb3B0cy5jbG9zZUJveE1hcmdpbiB8fCBcIjJweFwiO1xuICB0aGlzLmNsb3NlQm94VVJMXyA9IG9wdF9vcHRzLmNsb3NlQm94VVJMIHx8IFwiaHR0cDovL3d3dy5nb29nbGUuY29tL2ludGwvZW5fdXMvbWFwZmlsZXMvY2xvc2UuZ2lmXCI7XG4gIGlmIChvcHRfb3B0cy5jbG9zZUJveFVSTCA9PT0gXCJcIikge1xuICAgIHRoaXMuY2xvc2VCb3hVUkxfID0gXCJcIjtcbiAgfVxuICB0aGlzLmluZm9Cb3hDbGVhcmFuY2VfID0gb3B0X29wdHMuaW5mb0JveENsZWFyYW5jZSB8fCBuZXcgZ29vZ2xlLm1hcHMuU2l6ZSgxLCAxKTtcblxuICBpZiAodHlwZW9mIG9wdF9vcHRzLnZpc2libGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdF9vcHRzLmlzSGlkZGVuID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRfb3B0cy52aXNpYmxlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0X29wdHMudmlzaWJsZSA9ICFvcHRfb3B0cy5pc0hpZGRlbjtcbiAgICB9XG4gIH1cbiAgdGhpcy5pc0hpZGRlbl8gPSAhb3B0X29wdHMudmlzaWJsZTtcblxuICB0aGlzLmFsaWduQm90dG9tXyA9IG9wdF9vcHRzLmFsaWduQm90dG9tIHx8IGZhbHNlO1xuICB0aGlzLnBhbmVfID0gb3B0X29wdHMucGFuZSB8fCBcImZsb2F0UGFuZVwiO1xuICB0aGlzLmVuYWJsZUV2ZW50UHJvcGFnYXRpb25fID0gb3B0X29wdHMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbiB8fCBmYWxzZTtcblxuICB0aGlzLmRpdl8gPSBudWxsO1xuICB0aGlzLmNsb3NlTGlzdGVuZXJfID0gbnVsbDtcbiAgdGhpcy5tb3ZlTGlzdGVuZXJfID0gbnVsbDtcbiAgdGhpcy5tYXBMaXN0ZW5lcl8gPSBudWxsO1xuICB0aGlzLmNvbnRleHRMaXN0ZW5lcl8gPSBudWxsO1xuICB0aGlzLmV2ZW50TGlzdGVuZXJzXyA9IG51bGw7XG4gIHRoaXMuZml4ZWRXaWR0aFNldF8gPSBudWxsO1xufVxuXG4vKiBJbmZvQm94IGV4dGVuZHMgT3ZlcmxheVZpZXcgaW4gdGhlIEdvb2dsZSBNYXBzIEFQSSB2My5cbiAqL1xuSW5mb0JveC5wcm90b3R5cGUgPSBuZXcgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcoKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBESVYgcmVwcmVzZW50aW5nIHRoZSBJbmZvQm94LlxuICogQHByaXZhdGVcbiAqL1xuSW5mb0JveC5wcm90b3R5cGUuY3JlYXRlSW5mb0JveERpdl8gPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGk7XG4gIHZhciBldmVudHM7XG4gIHZhciBidztcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBUaGlzIGhhbmRsZXIgcHJldmVudHMgYW4gZXZlbnQgaW4gdGhlIEluZm9Cb3ggZnJvbSBiZWluZyBwYXNzZWQgb24gdG8gdGhlIG1hcC5cbiAgLy9cbiAgdmFyIGNhbmNlbEhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoaXMgaGFuZGxlciBpZ25vcmVzIHRoZSBjdXJyZW50IGV2ZW50IGluIHRoZSBJbmZvQm94IGFuZCBjb25kaXRpb25hbGx5IHByZXZlbnRzXG4gIC8vIHRoZSBldmVudCBmcm9tIGJlaW5nIHBhc3NlZCBvbiB0byB0aGUgbWFwLiBJdCBpcyB1c2VkIGZvciB0aGUgY29udGV4dG1lbnUgZXZlbnQuXG4gIC8vXG4gIHZhciBpZ25vcmVIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcblxuICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAoIW1lLmVuYWJsZUV2ZW50UHJvcGFnYXRpb25fKSB7XG5cbiAgICAgIGNhbmNlbEhhbmRsZXIoZSk7XG4gICAgfVxuICB9O1xuXG4gIGlmICghdGhpcy5kaXZfKSB7XG5cbiAgICB0aGlzLmRpdl8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgdGhpcy5zZXRCb3hTdHlsZV8oKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5jb250ZW50Xy5ub2RlVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5kaXZfLmlubmVySFRNTCA9IHRoaXMuZ2V0Q2xvc2VCb3hJbWdfKCkgKyB0aGlzLmNvbnRlbnRfO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdl8uaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZ18oKTtcbiAgICAgIHRoaXMuZGl2Xy5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRfKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIEluZm9Cb3ggRElWIHRvIHRoZSBET01cbiAgICB0aGlzLmdldFBhbmVzKClbdGhpcy5wYW5lX10uYXBwZW5kQ2hpbGQodGhpcy5kaXZfKTtcblxuICAgIHRoaXMuYWRkQ2xpY2tIYW5kbGVyXygpO1xuXG4gICAgaWYgKHRoaXMuZGl2Xy5zdHlsZS53aWR0aCkge1xuXG4gICAgICB0aGlzLmZpeGVkV2lkdGhTZXRfID0gdHJ1ZTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmICh0aGlzLm1heFdpZHRoXyAhPT0gMCAmJiB0aGlzLmRpdl8ub2Zmc2V0V2lkdGggPiB0aGlzLm1heFdpZHRoXykge1xuXG4gICAgICAgIHRoaXMuZGl2Xy5zdHlsZS53aWR0aCA9IHRoaXMubWF4V2lkdGhfO1xuICAgICAgICB0aGlzLmZpeGVkV2lkdGhTZXRfID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHsgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGlzIG5lZWRlZCB0byBvdmVyY29tZSBwcm9ibGVtcyB3aXRoIE1TSUVcblxuICAgICAgICBidyA9IHRoaXMuZ2V0Qm94V2lkdGhzXygpO1xuXG4gICAgICAgIHRoaXMuZGl2Xy5zdHlsZS53aWR0aCA9ICh0aGlzLmRpdl8ub2Zmc2V0V2lkdGggLSBidy5sZWZ0IC0gYncucmlnaHQpICsgXCJweFwiO1xuICAgICAgICB0aGlzLmZpeGVkV2lkdGhTZXRfID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wYW5Cb3hfKHRoaXMuZGlzYWJsZUF1dG9QYW5fKTtcblxuICAgIGlmICghdGhpcy5lbmFibGVFdmVudFByb3BhZ2F0aW9uXykge1xuXG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzXyA9IFtdO1xuXG4gICAgICAvLyBDYW5jZWwgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAvL1xuICAgICAgLy8gTm90ZTogbW91c2Vtb3ZlIG5vdCBpbmNsdWRlZCAodG8gcmVzb2x2ZSBJc3N1ZSAxNTIpXG4gICAgICBldmVudHMgPSBbXCJtb3VzZWRvd25cIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW91dFwiLCBcIm1vdXNldXBcIixcbiAgICAgIFwiY2xpY2tcIiwgXCJkYmxjbGlja1wiLCBcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaGVuZFwiLCBcInRvdWNobW92ZVwiXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNfLnB1c2goZ29vZ2xlLm1hcHMuZXZlbnQuYWRkRG9tTGlzdGVuZXIodGhpcy5kaXZfLCBldmVudHNbaV0sIGNhbmNlbEhhbmRsZXIpKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgR29vZ2xlIGJ1ZyB0aGF0IGNhdXNlcyB0aGUgY3Vyc29yIHRvIGNoYW5nZSB0byBhIHBvaW50ZXJcbiAgICAgIC8vIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG92ZXIgYSBtYXJrZXIgdW5kZXJuZWF0aCBJbmZvQm94LlxuICAgICAgdGhpcy5ldmVudExpc3RlbmVyc18ucHVzaChnb29nbGUubWFwcy5ldmVudC5hZGREb21MaXN0ZW5lcih0aGlzLmRpdl8sIFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCI7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0TGlzdGVuZXJfID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkRG9tTGlzdGVuZXIodGhpcy5kaXZfLCBcImNvbnRleHRtZW51XCIsIGlnbm9yZUhhbmRsZXIpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBESVYgY29udGFpbmluZyB0aGUgSW5mb0JveCdzIGNvbnRlbnQgaXMgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAgICAgKiBAbmFtZSBJbmZvQm94I2RvbXJlYWR5XG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCBcImRvbXJlYWR5XCIpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIEhUTUwgPElNRz4gdGFnIGZvciB0aGUgY2xvc2UgYm94LlxuICogQHByaXZhdGVcbiAqL1xuSW5mb0JveC5wcm90b3R5cGUuZ2V0Q2xvc2VCb3hJbWdfID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBpbWcgPSBcIlwiO1xuXG4gIGlmICh0aGlzLmNsb3NlQm94VVJMXyAhPT0gXCJcIikge1xuXG4gICAgaW1nICA9IFwiPGltZ1wiO1xuICAgIGltZyArPSBcIiBzcmM9J1wiICsgdGhpcy5jbG9zZUJveFVSTF8gKyBcIidcIjtcbiAgICBpbWcgKz0gXCIgYWxpZ249cmlnaHRcIjsgLy8gRG8gdGhpcyBiZWNhdXNlIE9wZXJhIGNob2tlcyBvbiBzdHlsZT0nZmxvYXQ6IHJpZ2h0OydcbiAgICBpbWcgKz0gXCIgc3R5bGU9J1wiO1xuICAgIGltZyArPSBcIiBwb3NpdGlvbjogcmVsYXRpdmU7XCI7IC8vIFJlcXVpcmVkIGJ5IE1TSUVcbiAgICBpbWcgKz0gXCIgY3Vyc29yOiBwb2ludGVyO1wiO1xuICAgIGltZyArPSBcIiBtYXJnaW46IFwiICsgdGhpcy5jbG9zZUJveE1hcmdpbl8gKyBcIjtcIjtcbiAgICBpbWcgKz0gXCInPlwiO1xuICB9XG5cbiAgcmV0dXJuIGltZztcbn07XG5cbi8qKlxuICogQWRkcyB0aGUgY2xpY2sgaGFuZGxlciB0byB0aGUgSW5mb0JveCBjbG9zZSBib3guXG4gKiBAcHJpdmF0ZVxuICovXG5JbmZvQm94LnByb3RvdHlwZS5hZGRDbGlja0hhbmRsZXJfID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBjbG9zZUJveDtcblxuICBpZiAodGhpcy5jbG9zZUJveFVSTF8gIT09IFwiXCIpIHtcblxuICAgIGNsb3NlQm94ID0gdGhpcy5kaXZfLmZpcnN0Q2hpbGQ7XG4gICAgdGhpcy5jbG9zZUxpc3RlbmVyXyA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZERvbUxpc3RlbmVyKGNsb3NlQm94LCBcImNsaWNrXCIsIHRoaXMuZ2V0Q2xvc2VDbGlja0hhbmRsZXJfKCkpO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLmNsb3NlTGlzdGVuZXJfID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBjbG9zZSBib3ggb2YgYW4gSW5mb0JveC5cbiAqIEBwcml2YXRlXG4gKi9cbkluZm9Cb3gucHJvdG90eXBlLmdldENsb3NlQ2xpY2tIYW5kbGVyXyA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbWUgPSB0aGlzO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZSkge1xuXG4gICAgLy8gMS4wLjMgZml4OiBBbHdheXMgcHJldmVudCBwcm9wYWdhdGlvbiBvZiBhIGNsb3NlIGJveCBjbGljayB0byB0aGUgbWFwOlxuICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcblxuICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgSW5mb0JveCdzIGNsb3NlIGJveCBpcyBjbGlja2VkLlxuICAgICAqIEBuYW1lIEluZm9Cb3gjY2xvc2VjbGlja1xuICAgICAqIEBldmVudFxuICAgICAqL1xuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIobWUsIFwiY2xvc2VjbGlja1wiKTtcblxuICAgIG1lLmNsb3NlKCk7XG4gIH07XG59O1xuXG4vKipcbiAqIFBhbnMgdGhlIG1hcCBzbyB0aGF0IHRoZSBJbmZvQm94IGFwcGVhcnMgZW50aXJlbHkgd2l0aGluIHRoZSBtYXAncyB2aXNpYmxlIGFyZWEuXG4gKiBAcHJpdmF0ZVxuICovXG5JbmZvQm94LnByb3RvdHlwZS5wYW5Cb3hfID0gZnVuY3Rpb24gKGRpc2FibGVQYW4pIHtcblxuICB2YXIgbWFwO1xuICB2YXIgYm91bmRzO1xuICB2YXIgeE9mZnNldCA9IDAsIHlPZmZzZXQgPSAwO1xuXG4gIGlmICghZGlzYWJsZVBhbikge1xuXG4gICAgbWFwID0gdGhpcy5nZXRNYXAoKTtcblxuICAgIGlmIChtYXAgaW5zdGFuY2VvZiBnb29nbGUubWFwcy5NYXApIHsgLy8gT25seSBwYW4gaWYgYXR0YWNoZWQgdG8gbWFwLCBub3QgcGFub3JhbWFcblxuICAgICAgaWYgKCFtYXAuZ2V0Qm91bmRzKCkuY29udGFpbnModGhpcy5wb3NpdGlvbl8pKSB7XG4gICAgICAvLyBNYXJrZXIgbm90IGluIHZpc2libGUgYXJlYSBvZiBtYXAsIHNvIHNldCBjZW50ZXJcbiAgICAgIC8vIG9mIG1hcCB0byB0aGUgbWFya2VyIHBvc2l0aW9uIGZpcnN0LlxuICAgICAgICBtYXAuc2V0Q2VudGVyKHRoaXMucG9zaXRpb25fKTtcbiAgICAgIH1cblxuICAgICAgYm91bmRzID0gbWFwLmdldEJvdW5kcygpO1xuXG4gICAgICB2YXIgbWFwRGl2ID0gbWFwLmdldERpdigpO1xuICAgICAgdmFyIG1hcFdpZHRoID0gbWFwRGl2Lm9mZnNldFdpZHRoO1xuICAgICAgdmFyIG1hcEhlaWdodCA9IG1hcERpdi5vZmZzZXRIZWlnaHQ7XG4gICAgICB2YXIgaXdPZmZzZXRYID0gdGhpcy5waXhlbE9mZnNldF8ud2lkdGg7XG4gICAgICB2YXIgaXdPZmZzZXRZID0gdGhpcy5waXhlbE9mZnNldF8uaGVpZ2h0O1xuICAgICAgdmFyIGl3V2lkdGggPSB0aGlzLmRpdl8ub2Zmc2V0V2lkdGg7XG4gICAgICB2YXIgaXdIZWlnaHQgPSB0aGlzLmRpdl8ub2Zmc2V0SGVpZ2h0O1xuICAgICAgdmFyIHBhZFggPSB0aGlzLmluZm9Cb3hDbGVhcmFuY2VfLndpZHRoO1xuICAgICAgdmFyIHBhZFkgPSB0aGlzLmluZm9Cb3hDbGVhcmFuY2VfLmhlaWdodDtcbiAgICAgIHZhciBwaXhQb3NpdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpLmZyb21MYXRMbmdUb0NvbnRhaW5lclBpeGVsKHRoaXMucG9zaXRpb25fKTtcblxuICAgICAgaWYgKHBpeFBvc2l0aW9uLnggPCAoLWl3T2Zmc2V0WCArIHBhZFgpKSB7XG4gICAgICAgIHhPZmZzZXQgPSBwaXhQb3NpdGlvbi54ICsgaXdPZmZzZXRYIC0gcGFkWDtcbiAgICAgIH0gZWxzZSBpZiAoKHBpeFBvc2l0aW9uLnggKyBpd1dpZHRoICsgaXdPZmZzZXRYICsgcGFkWCkgPiBtYXBXaWR0aCkge1xuICAgICAgICB4T2Zmc2V0ID0gcGl4UG9zaXRpb24ueCArIGl3V2lkdGggKyBpd09mZnNldFggKyBwYWRYIC0gbWFwV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hbGlnbkJvdHRvbV8pIHtcbiAgICAgICAgaWYgKHBpeFBvc2l0aW9uLnkgPCAoLWl3T2Zmc2V0WSArIHBhZFkgKyBpd0hlaWdodCkpIHtcbiAgICAgICAgICB5T2Zmc2V0ID0gcGl4UG9zaXRpb24ueSArIGl3T2Zmc2V0WSAtIHBhZFkgLSBpd0hlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICgocGl4UG9zaXRpb24ueSArIGl3T2Zmc2V0WSArIHBhZFkpID4gbWFwSGVpZ2h0KSB7XG4gICAgICAgICAgeU9mZnNldCA9IHBpeFBvc2l0aW9uLnkgKyBpd09mZnNldFkgKyBwYWRZIC0gbWFwSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGl4UG9zaXRpb24ueSA8ICgtaXdPZmZzZXRZICsgcGFkWSkpIHtcbiAgICAgICAgICB5T2Zmc2V0ID0gcGl4UG9zaXRpb24ueSArIGl3T2Zmc2V0WSAtIHBhZFk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHBpeFBvc2l0aW9uLnkgKyBpd0hlaWdodCArIGl3T2Zmc2V0WSArIHBhZFkpID4gbWFwSGVpZ2h0KSB7XG4gICAgICAgICAgeU9mZnNldCA9IHBpeFBvc2l0aW9uLnkgKyBpd0hlaWdodCArIGl3T2Zmc2V0WSArIHBhZFkgLSBtYXBIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCEoeE9mZnNldCA9PT0gMCAmJiB5T2Zmc2V0ID09PSAwKSkge1xuXG4gICAgICAgIC8vIE1vdmUgdGhlIG1hcCB0byB0aGUgc2hpZnRlZCBjZW50ZXIuXG4gICAgICAgIC8vXG4gICAgICAgIHZhciBjID0gbWFwLmdldENlbnRlcigpO1xuICAgICAgICBtYXAucGFuQnkoeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHN0eWxlIG9mIHRoZSBJbmZvQm94IGJ5IHNldHRpbmcgdGhlIHN0eWxlIHNoZWV0IGFuZCBhcHBseWluZ1xuICogb3RoZXIgc3BlY2lmaWMgc3R5bGVzIHJlcXVlc3RlZC5cbiAqIEBwcml2YXRlXG4gKi9cbkluZm9Cb3gucHJvdG90eXBlLnNldEJveFN0eWxlXyA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgaSwgYm94U3R5bGU7XG5cbiAgaWYgKHRoaXMuZGl2Xykge1xuXG4gICAgLy8gQXBwbHkgc3R5bGUgdmFsdWVzIGZyb20gdGhlIHN0eWxlIHNoZWV0IGRlZmluZWQgaW4gdGhlIGJveENsYXNzIHBhcmFtZXRlcjpcbiAgICB0aGlzLmRpdl8uY2xhc3NOYW1lID0gdGhpcy5ib3hDbGFzc187XG5cbiAgICAvLyBDbGVhciBleGlzdGluZyBpbmxpbmUgc3R5bGUgdmFsdWVzOlxuICAgIHRoaXMuZGl2Xy5zdHlsZS5jc3NUZXh0ID0gXCJcIjtcblxuICAgIC8vIEFwcGx5IHN0eWxlIHZhbHVlcyBkZWZpbmVkIGluIHRoZSBib3hTdHlsZSBwYXJhbWV0ZXI6XG4gICAgYm94U3R5bGUgPSB0aGlzLmJveFN0eWxlXztcbiAgICBmb3IgKGkgaW4gYm94U3R5bGUpIHtcblxuICAgICAgaWYgKGJveFN0eWxlLmhhc093blByb3BlcnR5KGkpKSB7XG5cbiAgICAgICAgdGhpcy5kaXZfLnN0eWxlW2ldID0gYm94U3R5bGVbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRml4IGZvciBpT1MgZGlzYXBwZWFyaW5nIEluZm9Cb3ggcHJvYmxlbS5cbiAgICAvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85MjI5NTM1L2dvb2dsZS1tYXBzLW1hcmtlcnMtZGlzYXBwZWFyLWF0LWNlcnRhaW4tem9vbS1sZXZlbC1vbmx5LW9uLWlwaG9uZS1pcGFkXG4gICAgdGhpcy5kaXZfLnN0eWxlLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWigwKVwiO1xuXG4gICAgLy8gRml4IHVwIG9wYWNpdHkgc3R5bGUgZm9yIGJlbmVmaXQgb2YgTVNJRTpcbiAgICAvL1xuICAgIGlmICh0eXBlb2YgdGhpcy5kaXZfLnN0eWxlLm9wYWNpdHkgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5kaXZfLnN0eWxlLm9wYWNpdHkgIT09IFwiXCIpIHtcbiAgICAgIC8vIFNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Nzcy9vcGFjaXR5Lmh0bWxcbiAgICAgIHRoaXMuZGl2Xy5zdHlsZS5Nc0ZpbHRlciA9IFwiXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PVwiICsgKHRoaXMuZGl2Xy5zdHlsZS5vcGFjaXR5ICogMTAwKSArIFwiKVxcXCJcIjtcbiAgICAgIHRoaXMuZGl2Xy5zdHlsZS5maWx0ZXIgPSBcImFscGhhKG9wYWNpdHk9XCIgKyAodGhpcy5kaXZfLnN0eWxlLm9wYWNpdHkgKiAxMDApICsgXCIpXCI7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgcmVxdWlyZWQgc3R5bGVzOlxuICAgIC8vXG4gICAgdGhpcy5kaXZfLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIHRoaXMuZGl2Xy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgaWYgKHRoaXMuekluZGV4XyAhPT0gbnVsbCkge1xuXG4gICAgICB0aGlzLmRpdl8uc3R5bGUuekluZGV4ID0gdGhpcy56SW5kZXhfO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZGl2Xy5zdHlsZS5vdmVyZmxvdykge1xuICAgICAgdGhpcy5kaXZfLnN0eWxlLm92ZXJmbG93ID0gXCJhdXRvXCI7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgd2lkdGhzIG9mIHRoZSBib3JkZXJzIG9mIHRoZSBJbmZvQm94LlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge09iamVjdH0gd2lkdGhzIG9iamVjdCAodG9wLCBib3R0b20gbGVmdCwgcmlnaHQpXG4gKi9cbkluZm9Cb3gucHJvdG90eXBlLmdldEJveFdpZHRoc18gPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGNvbXB1dGVkU3R5bGU7XG4gIHZhciBidyA9IHt0b3A6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDB9O1xuICB2YXIgYm94ID0gdGhpcy5kaXZfO1xuXG4gIGlmIChkb2N1bWVudC5kZWZhdWx0VmlldyAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG5cbiAgICBjb21wdXRlZFN0eWxlID0gYm94Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShib3gsIFwiXCIpO1xuXG4gICAgaWYgKGNvbXB1dGVkU3R5bGUpIHtcblxuICAgICAgLy8gVGhlIGNvbXB1dGVkIHN0eWxlcyBhcmUgYWx3YXlzIGluIHBpeGVsIHVuaXRzIChnb29kISlcbiAgICAgIGJ3LnRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwO1xuICAgICAgYncuYm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCwgMTApIHx8IDA7XG4gICAgICBidy5sZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xuICAgICAgYncucmlnaHQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgsIDEwKSB8fCAwO1xuICAgIH1cblxuICB9IGVsc2UgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUpIHsgLy8gTVNJRVxuXG4gICAgaWYgKGJveC5jdXJyZW50U3R5bGUpIHtcblxuICAgICAgLy8gVGhlIGN1cnJlbnQgc3R5bGVzIG1heSBub3QgYmUgaW4gcGl4ZWwgdW5pdHMsIGJ1dCBhc3N1bWUgdGhleSBhcmUgKGJhZCEpXG4gICAgICBidy50b3AgPSBwYXJzZUludChib3guY3VycmVudFN0eWxlLmJvcmRlclRvcFdpZHRoLCAxMCkgfHwgMDtcbiAgICAgIGJ3LmJvdHRvbSA9IHBhcnNlSW50KGJveC5jdXJyZW50U3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwKSB8fCAwO1xuICAgICAgYncubGVmdCA9IHBhcnNlSW50KGJveC5jdXJyZW50U3R5bGUuYm9yZGVyTGVmdFdpZHRoLCAxMCkgfHwgMDtcbiAgICAgIGJ3LnJpZ2h0ID0gcGFyc2VJbnQoYm94LmN1cnJlbnRTdHlsZS5ib3JkZXJSaWdodFdpZHRoLCAxMCkgfHwgMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnc7XG59O1xuXG4vKipcbiAqIEludm9rZWQgd2hlbiA8dHQ+Y2xvc2U8L3R0PiBpcyBjYWxsZWQuIERvIG5vdCBjYWxsIGl0IGRpcmVjdGx5LlxuICovXG5JbmZvQm94LnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblxuICBpZiAodGhpcy5kaXZfKSB7XG5cbiAgICB0aGlzLmRpdl8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdl8pO1xuICAgIHRoaXMuZGl2XyA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogRHJhd3MgdGhlIEluZm9Cb3ggYmFzZWQgb24gdGhlIGN1cnJlbnQgbWFwIHByb2plY3Rpb24gYW5kIHpvb20gbGV2ZWwuXG4gKi9cbkluZm9Cb3gucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5jcmVhdGVJbmZvQm94RGl2XygpO1xuXG4gIHZhciBwaXhQb3NpdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpLmZyb21MYXRMbmdUb0RpdlBpeGVsKHRoaXMucG9zaXRpb25fKTtcblxuICB0aGlzLmRpdl8uc3R5bGUubGVmdCA9IChwaXhQb3NpdGlvbi54ICsgdGhpcy5waXhlbE9mZnNldF8ud2lkdGgpICsgXCJweFwiO1xuICBcbiAgaWYgKHRoaXMuYWxpZ25Cb3R0b21fKSB7XG4gICAgdGhpcy5kaXZfLnN0eWxlLmJvdHRvbSA9IC0ocGl4UG9zaXRpb24ueSArIHRoaXMucGl4ZWxPZmZzZXRfLmhlaWdodCkgKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kaXZfLnN0eWxlLnRvcCA9IChwaXhQb3NpdGlvbi55ICsgdGhpcy5waXhlbE9mZnNldF8uaGVpZ2h0KSArIFwicHhcIjtcbiAgfVxuXG4gIGlmICh0aGlzLmlzSGlkZGVuXykge1xuXG4gICAgdGhpcy5kaXZfLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB0aGlzLmRpdl8uc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG9wdGlvbnMgZm9yIHRoZSBJbmZvQm94LiBOb3RlIHRoYXQgY2hhbmdlcyB0byB0aGUgPHR0Pm1heFdpZHRoPC90dD4sXG4gKiAgPHR0PmNsb3NlQm94TWFyZ2luPC90dD4sIDx0dD5jbG9zZUJveFVSTDwvdHQ+LCBhbmQgPHR0PmVuYWJsZUV2ZW50UHJvcGFnYXRpb248L3R0PlxuICogIHByb3BlcnRpZXMgaGF2ZSBubyBhZmZlY3QgdW50aWwgdGhlIGN1cnJlbnQgSW5mb0JveCBpcyA8dHQ+Y2xvc2U8L3R0PmQgYW5kIGEgbmV3IG9uZVxuICogIGlzIDx0dD5vcGVuPC90dD5lZC5cbiAqIEBwYXJhbSB7SW5mb0JveE9wdGlvbnN9IG9wdF9vcHRzXG4gKi9cbkluZm9Cb3gucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0X29wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRfb3B0cy5ib3hDbGFzcyAhPT0gXCJ1bmRlZmluZWRcIikgeyAvLyBNdXN0IGJlIGZpcnN0XG5cbiAgICB0aGlzLmJveENsYXNzXyA9IG9wdF9vcHRzLmJveENsYXNzO1xuICAgIHRoaXMuc2V0Qm94U3R5bGVfKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRfb3B0cy5ib3hTdHlsZSAhPT0gXCJ1bmRlZmluZWRcIikgeyAvLyBNdXN0IGJlIHNlY29uZFxuXG4gICAgdGhpcy5ib3hTdHlsZV8gPSBvcHRfb3B0cy5ib3hTdHlsZTtcbiAgICB0aGlzLnNldEJveFN0eWxlXygpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0X29wdHMuY29udGVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXG4gICAgdGhpcy5zZXRDb250ZW50KG9wdF9vcHRzLmNvbnRlbnQpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0X29wdHMuZGlzYWJsZUF1dG9QYW4gIT09IFwidW5kZWZpbmVkXCIpIHtcblxuICAgIHRoaXMuZGlzYWJsZUF1dG9QYW5fID0gb3B0X29wdHMuZGlzYWJsZUF1dG9QYW47XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRfb3B0cy5tYXhXaWR0aCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXG4gICAgdGhpcy5tYXhXaWR0aF8gPSBvcHRfb3B0cy5tYXhXaWR0aDtcbiAgfVxuICBpZiAodHlwZW9mIG9wdF9vcHRzLnBpeGVsT2Zmc2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cbiAgICB0aGlzLnBpeGVsT2Zmc2V0XyA9IG9wdF9vcHRzLnBpeGVsT2Zmc2V0O1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0X29wdHMuYWxpZ25Cb3R0b20gIT09IFwidW5kZWZpbmVkXCIpIHtcblxuICAgIHRoaXMuYWxpZ25Cb3R0b21fID0gb3B0X29wdHMuYWxpZ25Cb3R0b207XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRfb3B0cy5wb3NpdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuXG4gICAgdGhpcy5zZXRQb3NpdGlvbihvcHRfb3B0cy5wb3NpdGlvbik7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRfb3B0cy56SW5kZXggIT09IFwidW5kZWZpbmVkXCIpIHtcblxuICAgIHRoaXMuc2V0WkluZGV4KG9wdF9vcHRzLnpJbmRleCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRfb3B0cy5jbG9zZUJveE1hcmdpbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuXG4gICAgdGhpcy5jbG9zZUJveE1hcmdpbl8gPSBvcHRfb3B0cy5jbG9zZUJveE1hcmdpbjtcbiAgfVxuICBpZiAodHlwZW9mIG9wdF9vcHRzLmNsb3NlQm94VVJMICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cbiAgICB0aGlzLmNsb3NlQm94VVJMXyA9IG9wdF9vcHRzLmNsb3NlQm94VVJMO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0X29wdHMuaW5mb0JveENsZWFyYW5jZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuXG4gICAgdGhpcy5pbmZvQm94Q2xlYXJhbmNlXyA9IG9wdF9vcHRzLmluZm9Cb3hDbGVhcmFuY2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRfb3B0cy5pc0hpZGRlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuXG4gICAgdGhpcy5pc0hpZGRlbl8gPSBvcHRfb3B0cy5pc0hpZGRlbjtcbiAgfVxuICBpZiAodHlwZW9mIG9wdF9vcHRzLnZpc2libGUgIT09IFwidW5kZWZpbmVkXCIpIHtcblxuICAgIHRoaXMuaXNIaWRkZW5fID0gIW9wdF9vcHRzLnZpc2libGU7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRfb3B0cy5lbmFibGVFdmVudFByb3BhZ2F0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cbiAgICB0aGlzLmVuYWJsZUV2ZW50UHJvcGFnYXRpb25fID0gb3B0X29wdHMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbjtcbiAgfVxuXG4gIGlmICh0aGlzLmRpdl8pIHtcblxuICAgIHRoaXMuZHJhdygpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIEluZm9Cb3guXG4gKiAgVGhlIGNvbnRlbnQgY2FuIGJlIHBsYWluIHRleHQgb3IgYW4gSFRNTCBET00gbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfE5vZGV9IGNvbnRlbnRcbiAqL1xuSW5mb0JveC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHRoaXMuY29udGVudF8gPSBjb250ZW50O1xuXG4gIGlmICh0aGlzLmRpdl8pIHtcblxuICAgIGlmICh0aGlzLmNsb3NlTGlzdGVuZXJfKSB7XG5cbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuY2xvc2VMaXN0ZW5lcl8pO1xuICAgICAgdGhpcy5jbG9zZUxpc3RlbmVyXyA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gT2RkIGNvZGUgcmVxdWlyZWQgdG8gbWFrZSB0aGluZ3Mgd29yayB3aXRoIE1TSUUuXG4gICAgLy9cbiAgICBpZiAoIXRoaXMuZml4ZWRXaWR0aFNldF8pIHtcblxuICAgICAgdGhpcy5kaXZfLnN0eWxlLndpZHRoID0gXCJcIjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbnRlbnQubm9kZVR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMuZGl2Xy5pbm5lckhUTUwgPSB0aGlzLmdldENsb3NlQm94SW1nXygpICsgY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXZfLmlubmVySFRNTCA9IHRoaXMuZ2V0Q2xvc2VCb3hJbWdfKCk7XG4gICAgICB0aGlzLmRpdl8uYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuXG4gICAgLy8gUGVydmVyc2UgY29kZSByZXF1aXJlZCB0byBtYWtlIHRoaW5ncyB3b3JrIHdpdGggTVNJRS5cbiAgICAvLyAoRW5zdXJlcyB0aGUgY2xvc2UgYm94IGRvZXMsIGluIGZhY3QsIGZsb2F0IHRvIHRoZSByaWdodC4pXG4gICAgLy9cbiAgICBpZiAoIXRoaXMuZml4ZWRXaWR0aFNldF8pIHtcbiAgICAgIHRoaXMuZGl2Xy5zdHlsZS53aWR0aCA9IHRoaXMuZGl2Xy5vZmZzZXRXaWR0aCArIFwicHhcIjtcbiAgICAgIGlmICh0eXBlb2YgY29udGVudC5ub2RlVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmRpdl8uaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZ18oKSArIGNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpdl8uaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZ18oKTtcbiAgICAgICAgdGhpcy5kaXZfLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWRkQ2xpY2tIYW5kbGVyXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgY29udGVudCBvZiB0aGUgSW5mb0JveCBjaGFuZ2VzLlxuICAgKiBAbmFtZSBJbmZvQm94I2NvbnRlbnRfY2hhbmdlZFxuICAgKiBAZXZlbnRcbiAgICovXG4gIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgXCJjb250ZW50X2NoYW5nZWRcIik7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGdlb2dyYXBoaWMgbG9jYXRpb24gb2YgdGhlIEluZm9Cb3guXG4gKiBAcGFyYW0ge0xhdExuZ30gbGF0bG5nXG4gKi9cbkluZm9Cb3gucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKGxhdGxuZykge1xuXG4gIHRoaXMucG9zaXRpb25fID0gbGF0bG5nO1xuXG4gIGlmICh0aGlzLmRpdl8pIHtcblxuICAgIHRoaXMuZHJhdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgcG9zaXRpb24gb2YgdGhlIEluZm9Cb3ggY2hhbmdlcy5cbiAgICogQG5hbWUgSW5mb0JveCNwb3NpdGlvbl9jaGFuZ2VkXG4gICAqIEBldmVudFxuICAgKi9cbiAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCBcInBvc2l0aW9uX2NoYW5nZWRcIik7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHpJbmRleCBzdHlsZSBmb3IgdGhlIEluZm9Cb3guXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuSW5mb0JveC5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cbiAgdGhpcy56SW5kZXhfID0gaW5kZXg7XG5cbiAgaWYgKHRoaXMuZGl2Xykge1xuXG4gICAgdGhpcy5kaXZfLnN0eWxlLnpJbmRleCA9IGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgekluZGV4IG9mIHRoZSBJbmZvQm94IGNoYW5nZXMuXG4gICAqIEBuYW1lIEluZm9Cb3gjemluZGV4X2NoYW5nZWRcbiAgICogQGV2ZW50XG4gICAqL1xuICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsIFwiemluZGV4X2NoYW5nZWRcIik7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIEluZm9Cb3guXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmlzaWJsZVxuICovXG5JbmZvQm94LnByb3RvdHlwZS5zZXRWaXNpYmxlID0gZnVuY3Rpb24gKGlzVmlzaWJsZSkge1xuXG4gIHRoaXMuaXNIaWRkZW5fID0gIWlzVmlzaWJsZTtcbiAgaWYgKHRoaXMuZGl2Xykge1xuICAgIHRoaXMuZGl2Xy5zdHlsZS52aXNpYmlsaXR5ID0gKHRoaXMuaXNIaWRkZW5fID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBJbmZvQm94LlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuSW5mb0JveC5wcm90b3R5cGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcblxuICByZXR1cm4gdGhpcy5jb250ZW50Xztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBvZiB0aGUgSW5mb0JveC5cbiAqIEByZXR1cm5zIHtMYXRMbmd9XG4gKi9cbkluZm9Cb3gucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiB0aGlzLnBvc2l0aW9uXztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgekluZGV4IGZvciB0aGUgSW5mb0JveC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkluZm9Cb3gucHJvdG90eXBlLmdldFpJbmRleCA9IGZ1bmN0aW9uICgpIHtcblxuICByZXR1cm4gdGhpcy56SW5kZXhfO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIEluZm9Cb3ggaXMgdmlzaWJsZS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5JbmZvQm94LnByb3RvdHlwZS5nZXRWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBpc1Zpc2libGU7XG5cbiAgaWYgKCh0eXBlb2YgdGhpcy5nZXRNYXAoKSA9PT0gXCJ1bmRlZmluZWRcIikgfHwgKHRoaXMuZ2V0TWFwKCkgPT09IG51bGwpKSB7XG4gICAgaXNWaXNpYmxlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgaXNWaXNpYmxlID0gIXRoaXMuaXNIaWRkZW5fO1xuICB9XG4gIHJldHVybiBpc1Zpc2libGU7XG59O1xuXG4vKipcbiAqIFNob3dzIHRoZSBJbmZvQm94LiBbRGVwcmVjYXRlZDsgdXNlIDx0dD5zZXRWaXNpYmxlPC90dD4gaW5zdGVhZC5dXG4gKi9cbkluZm9Cb3gucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5pc0hpZGRlbl8gPSBmYWxzZTtcbiAgaWYgKHRoaXMuZGl2Xykge1xuICAgIHRoaXMuZGl2Xy5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gIH1cbn07XG5cbi8qKlxuICogSGlkZXMgdGhlIEluZm9Cb3guIFtEZXByZWNhdGVkOyB1c2UgPHR0PnNldFZpc2libGU8L3R0PiBpbnN0ZWFkLl1cbiAqL1xuSW5mb0JveC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmlzSGlkZGVuXyA9IHRydWU7XG4gIGlmICh0aGlzLmRpdl8pIHtcbiAgICB0aGlzLmRpdl8uc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkcyB0aGUgSW5mb0JveCB0byB0aGUgc3BlY2lmaWVkIG1hcCBvciBTdHJlZXQgVmlldyBwYW5vcmFtYS4gSWYgPHR0PmFuY2hvcjwvdHQ+XG4gKiAgKHVzdWFsbHkgYSA8dHQ+Z29vZ2xlLm1hcHMuTWFya2VyPC90dD4pIGlzIHNwZWNpZmllZCwgdGhlIHBvc2l0aW9uXG4gKiAgb2YgdGhlIEluZm9Cb3ggaXMgc2V0IHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgPHR0PmFuY2hvcjwvdHQ+LiBJZiB0aGVcbiAqICBhbmNob3IgaXMgZHJhZ2dlZCB0byBhIG5ldyBsb2NhdGlvbiwgdGhlIEluZm9Cb3ggbW92ZXMgYXMgd2VsbC5cbiAqIEBwYXJhbSB7TWFwfFN0cmVldFZpZXdQYW5vcmFtYX0gbWFwXG4gKiBAcGFyYW0ge01WQ09iamVjdH0gW2FuY2hvcl1cbiAqL1xuSW5mb0JveC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChtYXAsIGFuY2hvcikge1xuXG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgaWYgKGFuY2hvcikge1xuXG4gICAgdGhpcy5wb3NpdGlvbl8gPSBhbmNob3IuZ2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLm1vdmVMaXN0ZW5lcl8gPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihhbmNob3IsIFwicG9zaXRpb25fY2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5zZXRQb3NpdGlvbih0aGlzLmdldFBvc2l0aW9uKCkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tYXBMaXN0ZW5lcl8gPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihhbmNob3IsIFwibWFwX2NoYW5nZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBtZS5zZXRNYXAodGhpcy5tYXApO1xuICAgIH0pOyAgICBcbiAgfVxuXG4gIHRoaXMuc2V0TWFwKG1hcCk7XG5cbiAgaWYgKHRoaXMuZGl2Xykge1xuXG4gICAgdGhpcy5wYW5Cb3hfKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgSW5mb0JveCBmcm9tIHRoZSBtYXAuXG4gKi9cbkluZm9Cb3gucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBpO1xuXG4gIGlmICh0aGlzLmNsb3NlTGlzdGVuZXJfKSB7XG5cbiAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmNsb3NlTGlzdGVuZXJfKTtcbiAgICB0aGlzLmNsb3NlTGlzdGVuZXJfID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzXykge1xuICAgIFxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmV2ZW50TGlzdGVuZXJzXy5sZW5ndGg7IGkrKykge1xuXG4gICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmV2ZW50TGlzdGVuZXJzX1tpXSk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNfID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLm1vdmVMaXN0ZW5lcl8pIHtcblxuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMubW92ZUxpc3RlbmVyXyk7XG4gICAgdGhpcy5tb3ZlTGlzdGVuZXJfID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLm1hcExpc3RlbmVyXykge1xuICAgIFxuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMubWFwTGlzdGVuZXJfKTtcbiAgICB0aGlzLm1hcExpc3RlbmVyXyA9IG51bGw7ICAgIFxuICB9XG4gXG4gIGlmICh0aGlzLmNvbnRleHRMaXN0ZW5lcl8pIHtcblxuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuY29udGV4dExpc3RlbmVyXyk7XG4gICAgdGhpcy5jb250ZXh0TGlzdGVuZXJfID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuc2V0TWFwKG51bGwpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9Cb3g7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gRDovdml0YWxpay9sYXRjb20vfi9nb29nbGUtbWFwcy1pbmZvYm94L2luZm9ib3gtbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n");

/***/ })

});